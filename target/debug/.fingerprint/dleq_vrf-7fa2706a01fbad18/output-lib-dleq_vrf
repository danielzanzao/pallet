{"$message_type":"diagnostic","message":"the trait bound `<C as AffineRepr>::ScalarField: CanonicalDeserialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs","byte_start":845,"byte_end":875,"line_start":37,"line_end":37,"column_start":20,"column_end":50,"is_primary":true,"text":[{"text":"    type Scalars = <C as AffineRepr>::ScalarField;","highlight_start":20,"highlight_end":50}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `CanonicalDeserialize` is not implemented for `<C as AffineRepr>::ScalarField`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `InnerFlavor::Scalars`","code":null,"level":"note","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/flavor.rs","byte_start":3205,"byte_end":3225,"line_start":72,"line_end":72,"column_start":70,"column_end":90,"is_primary":true,"text":[{"text":"    type Scalars: ark_std::fmt::Debug + Clone + CanonicalSerialize + CanonicalDeserialize + zeroize::Zeroize;","highlight_start":70,"highlight_end":90}],"label":"required by this bound in `InnerFlavor::Scalars`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider further restricting the associated type","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs","byte_start":794,"byte_end":794,"line_start":35,"line_end":35,"column_start":47,"column_end":47,"is_primary":true,"text":[{"text":"impl<C: AffineRepr> InnerFlavor for ThinVrf<C> {","highlight_start":47,"highlight_end":47}],"label":null,"suggested_replacement":" where <C as AffineRepr>::ScalarField: CanonicalDeserialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `<C as AffineRepr>::ScalarField: CanonicalDeserialize` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs:37:20\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    type Scalars = <C as AffineRepr>::ScalarField;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munsatisfied trait bound\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `CanonicalDeserialize` is not implemented for `<C as AffineRepr>::ScalarField`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `InnerFlavor::Scalars`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/flavor.rs:72:70\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mCanonicalSerialize + CanonicalDeserialize + zeroize::Zeroize;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `InnerFlavor::Scalars`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting the associated type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mimpl<C: AffineRepr> InnerFlavor for ThinVrf<C>\u001b[0m\u001b[0m\u001b[38;5;10m where <C as AffineRepr>::ScalarField: CanonicalDeserialize\u001b[0m\u001b[0m {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `<C as AffineRepr>::ScalarField: CanonicalSerialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs","byte_start":845,"byte_end":875,"line_start":37,"line_end":37,"column_start":20,"column_end":50,"is_primary":true,"text":[{"text":"    type Scalars = <C as AffineRepr>::ScalarField;","highlight_start":20,"highlight_end":50}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `CanonicalSerialize` is not implemented for `<C as AffineRepr>::ScalarField`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `InnerFlavor::Scalars`","code":null,"level":"note","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/flavor.rs","byte_start":3184,"byte_end":3202,"line_start":72,"line_end":72,"column_start":49,"column_end":67,"is_primary":true,"text":[{"text":"    type Scalars: ark_std::fmt::Debug + Clone + CanonicalSerialize + CanonicalDeserialize + zeroize::Zeroize;","highlight_start":49,"highlight_end":67}],"label":"required by this bound in `InnerFlavor::Scalars`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider further restricting the associated type","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs","byte_start":794,"byte_end":794,"line_start":35,"line_end":35,"column_start":47,"column_end":47,"is_primary":true,"text":[{"text":"impl<C: AffineRepr> InnerFlavor for ThinVrf<C> {","highlight_start":47,"highlight_end":47}],"label":null,"suggested_replacement":" where <C as AffineRepr>::ScalarField: CanonicalSerialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `<C as AffineRepr>::ScalarField: CanonicalSerialize` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs:37:20\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    type Scalars = <C as AffineRepr>::ScalarField;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munsatisfied trait bound\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `CanonicalSerialize` is not implemented for `<C as AffineRepr>::ScalarField`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `InnerFlavor::Scalars`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/flavor.rs:72:49\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m72\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mfmt::Debug + Clone + CanonicalSerialize + CanonicalDeserialize + zeroize\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `InnerFlavor::Scalars`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting the associated type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mimpl<C: AffineRepr> InnerFlavor for ThinVrf<C>\u001b[0m\u001b[0m\u001b[38;5;10m where <C as AffineRepr>::ScalarField: CanonicalSerialize\u001b[0m\u001b[0m {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `C: CanonicalDeserialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs","byte_start":896,"byte_end":897,"line_start":38,"line_end":38,"column_start":20,"column_end":21,"is_primary":true,"text":[{"text":"    type Affines = C;","highlight_start":20,"highlight_end":21}],"label":"the trait `CanonicalDeserialize` is not implemented for `C`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required by a bound in `InnerFlavor::Affines`","code":null,"level":"note","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/flavor.rs","byte_start":3315,"byte_end":3335,"line_start":73,"line_end":73,"column_start":70,"column_end":90,"is_primary":true,"text":[{"text":"    type Affines: ark_std::fmt::Debug + Clone + CanonicalSerialize + CanonicalDeserialize;","highlight_start":70,"highlight_end":90}],"label":"required by this bound in `InnerFlavor::Affines`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider further restricting type parameter `C` with trait `CanonicalDeserialize`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs","byte_start":766,"byte_end":766,"line_start":35,"line_end":35,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"impl<C: AffineRepr> InnerFlavor for ThinVrf<C> {","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":" + ark_serialize::CanonicalDeserialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `C: CanonicalDeserialize` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs:38:20\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    type Affines = C;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CanonicalDeserialize` is not implemented for `C`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `InnerFlavor::Affines`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/flavor.rs:73:70\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m73\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mCanonicalSerialize + CanonicalDeserialize;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `InnerFlavor::Affines`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `C` with trait `CanonicalDeserialize`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mimpl<C: AffineRepr\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::CanonicalDeserialize\u001b[0m\u001b[0m> InnerFlavor for ThinVrf<C> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `C: CanonicalSerialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs","byte_start":896,"byte_end":897,"line_start":38,"line_end":38,"column_start":20,"column_end":21,"is_primary":true,"text":[{"text":"    type Affines = C;","highlight_start":20,"highlight_end":21}],"label":"the trait `CanonicalSerialize` is not implemented for `C`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required by a bound in `InnerFlavor::Affines`","code":null,"level":"note","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/flavor.rs","byte_start":3294,"byte_end":3312,"line_start":73,"line_end":73,"column_start":49,"column_end":67,"is_primary":true,"text":[{"text":"    type Affines: ark_std::fmt::Debug + Clone + CanonicalSerialize + CanonicalDeserialize;","highlight_start":49,"highlight_end":67}],"label":"required by this bound in `InnerFlavor::Affines`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider further restricting type parameter `C` with trait `CanonicalSerialize`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs","byte_start":766,"byte_end":766,"line_start":35,"line_end":35,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"impl<C: AffineRepr> InnerFlavor for ThinVrf<C> {","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":" + ark_serialize::CanonicalSerialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `C: CanonicalSerialize` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs:38:20\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    type Affines = C;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CanonicalSerialize` is not implemented for `C`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `InnerFlavor::Affines`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/flavor.rs:73:49\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m73\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mfmt::Debug + Clone + CanonicalSerialize + CanonicalDeserialize;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `InnerFlavor::Affines`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `C` with trait `CanonicalSerialize`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mimpl<C: AffineRepr\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::CanonicalSerialize\u001b[0m\u001b[0m> InnerFlavor for ThinVrf<C> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `<F as Flavor>::ScalarField: CanonicalSerialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/flavor.rs","byte_start":4834,"byte_end":4852,"line_start":121,"line_end":121,"column_start":22,"column_end":40,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":22,"highlight_end":40}],"label":"the trait `CanonicalSerialize` is not implemented for `<F as Flavor>::ScalarField`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/flavor.rs","byte_start":4834,"byte_end":4852,"line_start":121,"line_end":121,"column_start":22,"column_end":40,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":22,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalSerialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":304,"byte_end":396,"line_start":19,"line_end":19,"column_start":1,"column_end":93,"is_primary":false,"text":[{"text":"pub fn derive_canonical_serialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":93}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `<F as Flavor>::ScalarField: CanonicalSerialize` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/flavor.rs:121:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CanonicalSerialize` is not implemented for `<F as Flavor>::ScalarField`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalSerialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `<F as Flavor>::ScalarField: CanonicalDeserialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/flavor.rs","byte_start":4853,"byte_end":4873,"line_start":121,"line_end":121,"column_start":41,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":41,"highlight_end":61}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/flavor.rs","byte_start":4853,"byte_end":4873,"line_start":121,"line_end":121,"column_start":41,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":41,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalDeserialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":567,"byte_end":661,"line_start":25,"line_end":25,"column_start":1,"column_end":95,"is_primary":false,"text":[{"text":"pub fn derive_canonical_deserialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `CanonicalDeserialize` is not implemented for `<F as Flavor>::ScalarField`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `<F as Flavor>::ScalarField: CanonicalDeserialize` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/flavor.rs:121:41\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munsatisfied trait bound\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `CanonicalDeserialize` is not implemented for `<F as Flavor>::ScalarField`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `<F as Flavor>::ScalarField: Valid` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/flavor.rs","byte_start":4853,"byte_end":4873,"line_start":121,"line_end":121,"column_start":41,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":41,"highlight_end":61}],"label":"the trait `Valid` is not implemented for `<F as Flavor>::ScalarField`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/flavor.rs","byte_start":4853,"byte_end":4873,"line_start":121,"line_end":121,"column_start":41,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":41,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalDeserialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":567,"byte_end":661,"line_start":25,"line_end":25,"column_start":1,"column_end":95,"is_primary":false,"text":[{"text":"pub fn derive_canonical_deserialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `<F as Flavor>::ScalarField: Valid` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/flavor.rs:121:41\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Valid` is not implemented for `<F as Flavor>::ScalarField`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `C: CanonicalSerialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/keys.rs","byte_start":528,"byte_end":546,"line_start":25,"line_end":25,"column_start":30,"column_end":48,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,Eq,Hash,CanonicalSerialize,CanonicalDeserialize)] // Copy, PartialOrd, Ord, Hash, ","highlight_start":30,"highlight_end":48}],"label":"the trait `CanonicalSerialize` is not implemented for `C`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/keys.rs","byte_start":528,"byte_end":546,"line_start":25,"line_end":25,"column_start":30,"column_end":48,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,Eq,Hash,CanonicalSerialize,CanonicalDeserialize)] // Copy, PartialOrd, Ord, Hash, ","highlight_start":30,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalSerialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":304,"byte_end":396,"line_start":19,"line_end":19,"column_start":1,"column_end":93,"is_primary":false,"text":[{"text":"pub fn derive_canonical_serialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":93}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider further restricting type parameter `C` with trait `CanonicalSerialize`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/keys.rs","byte_start":658,"byte_end":658,"line_start":27,"line_end":27,"column_start":35,"column_end":35,"is_primary":true,"text":[{"text":"pub struct PublicKey<C: AffineRepr>(pub C);","highlight_start":35,"highlight_end":35}],"label":null,"suggested_replacement":" + ark_serialize::CanonicalSerialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `C: CanonicalSerialize` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/keys.rs:25:30\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m(Debug,Clone,Eq,Hash,CanonicalSerialize,CanonicalDeserialize)] // Copy, \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CanonicalSerialize` is not implemented for `C`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalSerialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `C` with trait `CanonicalSerialize`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m27\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub struct PublicKey<C: AffineRepr\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::CanonicalSerialize\u001b[0m\u001b[0m>(pub C);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `C: CanonicalDeserialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/keys.rs","byte_start":547,"byte_end":567,"line_start":25,"line_end":25,"column_start":49,"column_end":69,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,Eq,Hash,CanonicalSerialize,CanonicalDeserialize)] // Copy, PartialOrd, Ord, Hash, ","highlight_start":49,"highlight_end":69}],"label":"the trait `CanonicalDeserialize` is not implemented for `C`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/keys.rs","byte_start":547,"byte_end":567,"line_start":25,"line_end":25,"column_start":49,"column_end":69,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,Eq,Hash,CanonicalSerialize,CanonicalDeserialize)] // Copy, PartialOrd, Ord, Hash, ","highlight_start":49,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalDeserialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":567,"byte_end":661,"line_start":25,"line_end":25,"column_start":1,"column_end":95,"is_primary":false,"text":[{"text":"pub fn derive_canonical_deserialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider further restricting type parameter `C` with trait `CanonicalDeserialize`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/keys.rs","byte_start":658,"byte_end":658,"line_start":27,"line_end":27,"column_start":35,"column_end":35,"is_primary":true,"text":[{"text":"pub struct PublicKey<C: AffineRepr>(pub C);","highlight_start":35,"highlight_end":35}],"label":null,"suggested_replacement":" + ark_serialize::CanonicalDeserialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `C: CanonicalDeserialize` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/keys.rs:25:49\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mh,CanonicalSerialize,CanonicalDeserialize)] // Copy, PartialOrd, Ord, Ha\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CanonicalDeserialize` is not implemented for `C`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `C` with trait `CanonicalDeserialize`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m27\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub struct PublicKey<C: AffineRepr\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::CanonicalDeserialize\u001b[0m\u001b[0m>(pub C);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `C: Valid` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/keys.rs","byte_start":547,"byte_end":567,"line_start":25,"line_end":25,"column_start":49,"column_end":69,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,Eq,Hash,CanonicalSerialize,CanonicalDeserialize)] // Copy, PartialOrd, Ord, Hash, ","highlight_start":49,"highlight_end":69}],"label":"the trait `Valid` is not implemented for `C`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/keys.rs","byte_start":547,"byte_end":567,"line_start":25,"line_end":25,"column_start":49,"column_end":69,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,Eq,Hash,CanonicalSerialize,CanonicalDeserialize)] // Copy, PartialOrd, Ord, Hash, ","highlight_start":49,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalDeserialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":567,"byte_end":661,"line_start":25,"line_end":25,"column_start":1,"column_end":95,"is_primary":false,"text":[{"text":"pub fn derive_canonical_deserialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider further restricting type parameter `C` with trait `Valid`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/keys.rs","byte_start":658,"byte_end":658,"line_start":27,"line_end":27,"column_start":35,"column_end":35,"is_primary":true,"text":[{"text":"pub struct PublicKey<C: AffineRepr>(pub C);","highlight_start":35,"highlight_end":35}],"label":null,"suggested_replacement":" + ark_serialize::Valid","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `C: Valid` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/keys.rs:25:49\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mze,CanonicalDeserialize)] // Copy, PartialOrd, Ord, Hash, \u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Valid` is not implemented for `C`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `C` with trait `Valid`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m27\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub struct PublicKey<C: AffineRepr\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::Valid\u001b[0m\u001b[0m>(pub C);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `C: CanonicalSerialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/vrf.rs","byte_start":2937,"byte_end":2955,"line_start":81,"line_end":81,"column_start":22,"column_end":40,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize)] // CanonicalDeserialize, Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash","highlight_start":22,"highlight_end":40}],"label":"the trait `CanonicalSerialize` is not implemented for `C`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/vrf.rs","byte_start":2937,"byte_end":2955,"line_start":81,"line_end":81,"column_start":22,"column_end":40,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize)] // CanonicalDeserialize, Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash","highlight_start":22,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalSerialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":304,"byte_end":396,"line_start":19,"line_end":19,"column_start":1,"column_end":93,"is_primary":false,"text":[{"text":"pub fn derive_canonical_serialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":93}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider further restricting type parameter `C` with trait `CanonicalSerialize`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/vrf.rs","byte_start":3068,"byte_end":3068,"line_start":82,"line_end":82,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"pub struct VrfInput<C: AffineRepr>(pub C);","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":" + ark_serialize::CanonicalSerialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `C: CanonicalSerialize` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/vrf.rs:81:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m81\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug,Clone,CanonicalSerialize)] // CanonicalDeserialize, Copy, De\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CanonicalSerialize` is not implemented for `C`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalSerialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `C` with trait `CanonicalSerialize`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m82\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub struct VrfInput<C: AffineRepr\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::CanonicalSerialize\u001b[0m\u001b[0m>(pub C);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `C: CanonicalSerialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/vrf.rs","byte_start":4232,"byte_end":4250,"line_start":112,"line_end":112,"column_start":35,"column_end":53,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,PartialEq,Eq,CanonicalSerialize,CanonicalDeserialize)] // Copy, Default, PartialOrd, Ord, Hash","highlight_start":35,"highlight_end":53}],"label":"the trait `CanonicalSerialize` is not implemented for `C`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/vrf.rs","byte_start":4232,"byte_end":4250,"line_start":112,"line_end":112,"column_start":35,"column_end":53,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,PartialEq,Eq,CanonicalSerialize,CanonicalDeserialize)] // Copy, Default, PartialOrd, Ord, Hash","highlight_start":35,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalSerialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":304,"byte_end":396,"line_start":19,"line_end":19,"column_start":1,"column_end":93,"is_primary":false,"text":[{"text":"pub fn derive_canonical_serialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":93}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider further restricting type parameter `C` with trait `CanonicalSerialize`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/vrf.rs","byte_start":4348,"byte_end":4348,"line_start":113,"line_end":113,"column_start":35,"column_end":35,"is_primary":true,"text":[{"text":"pub struct VrfPreOut<C: AffineRepr>(pub C);","highlight_start":35,"highlight_end":35}],"label":null,"suggested_replacement":" + ark_serialize::CanonicalSerialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `C: CanonicalSerialize` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/vrf.rs:112:35\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mg,Clone,PartialEq,Eq,CanonicalSerialize,CanonicalDeserialize)] // Copy,\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CanonicalSerialize` is not implemented for `C`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalSerialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `C` with trait `CanonicalSerialize`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub struct VrfPreOut<C: AffineRepr\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::CanonicalSerialize\u001b[0m\u001b[0m>(pub C);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `C: CanonicalDeserialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/vrf.rs","byte_start":4251,"byte_end":4271,"line_start":112,"line_end":112,"column_start":54,"column_end":74,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,PartialEq,Eq,CanonicalSerialize,CanonicalDeserialize)] // Copy, Default, PartialOrd, Ord, Hash","highlight_start":54,"highlight_end":74}],"label":"the trait `CanonicalDeserialize` is not implemented for `C`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/vrf.rs","byte_start":4251,"byte_end":4271,"line_start":112,"line_end":112,"column_start":54,"column_end":74,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,PartialEq,Eq,CanonicalSerialize,CanonicalDeserialize)] // Copy, Default, PartialOrd, Ord, Hash","highlight_start":54,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalDeserialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":567,"byte_end":661,"line_start":25,"line_end":25,"column_start":1,"column_end":95,"is_primary":false,"text":[{"text":"pub fn derive_canonical_deserialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider further restricting type parameter `C` with trait `CanonicalDeserialize`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/vrf.rs","byte_start":4348,"byte_end":4348,"line_start":113,"line_end":113,"column_start":35,"column_end":35,"is_primary":true,"text":[{"text":"pub struct VrfPreOut<C: AffineRepr>(pub C);","highlight_start":35,"highlight_end":35}],"label":null,"suggested_replacement":" + ark_serialize::CanonicalDeserialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `C: CanonicalDeserialize` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/vrf.rs:112:54\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mq,CanonicalSerialize,CanonicalDeserialize)] // Copy, Default, PartialOr\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CanonicalDeserialize` is not implemented for `C`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `C` with trait `CanonicalDeserialize`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub struct VrfPreOut<C: AffineRepr\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::CanonicalDeserialize\u001b[0m\u001b[0m>(pub C);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `C: Valid` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/vrf.rs","byte_start":4251,"byte_end":4271,"line_start":112,"line_end":112,"column_start":54,"column_end":74,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,PartialEq,Eq,CanonicalSerialize,CanonicalDeserialize)] // Copy, Default, PartialOrd, Ord, Hash","highlight_start":54,"highlight_end":74}],"label":"the trait `Valid` is not implemented for `C`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/vrf.rs","byte_start":4251,"byte_end":4271,"line_start":112,"line_end":112,"column_start":54,"column_end":74,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,PartialEq,Eq,CanonicalSerialize,CanonicalDeserialize)] // Copy, Default, PartialOrd, Ord, Hash","highlight_start":54,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalDeserialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":567,"byte_end":661,"line_start":25,"line_end":25,"column_start":1,"column_end":95,"is_primary":false,"text":[{"text":"pub fn derive_canonical_deserialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider further restricting type parameter `C` with trait `Valid`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/vrf.rs","byte_start":4348,"byte_end":4348,"line_start":113,"line_end":113,"column_start":35,"column_end":35,"is_primary":true,"text":[{"text":"pub struct VrfPreOut<C: AffineRepr>(pub C);","highlight_start":35,"highlight_end":35}],"label":null,"suggested_replacement":" + ark_serialize::Valid","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `C: Valid` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/vrf.rs:112:54\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mze,CanonicalDeserialize)] // Copy, Default, PartialOrd, Ord, Hash\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Valid` is not implemented for `C`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `C` with trait `Valid`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m113\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub struct VrfPreOut<C: AffineRepr\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::Valid\u001b[0m\u001b[0m>(pub C);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `K: CanonicalSerialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs","byte_start":3044,"byte_end":3046,"line_start":102,"line_end":102,"column_start":18,"column_end":20,"is_primary":true,"text":[{"text":"        t.append(&r);","highlight_start":18,"highlight_end":20}],"label":"the trait `CanonicalSerialize` is not implemented for `K`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs","byte_start":3037,"byte_end":3043,"line_start":102,"line_end":102,"column_start":11,"column_end":17,"is_primary":false,"text":[{"text":"        t.append(&r);","highlight_start":11,"highlight_end":17}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required by a bound in `Transcript::append`","code":null,"level":"note","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/ark-transcript/src/lib.rs","byte_start":10142,"byte_end":10160,"line_start":317,"line_end":317,"column_start":22,"column_end":40,"is_primary":true,"text":[{"text":"    pub fn append<O: CanonicalSerialize+?Sized>(&mut self, itm: &O) {","highlight_start":22,"highlight_end":40}],"label":"required by this bound in `Transcript::append`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider further restricting type parameter `K` with trait `CanonicalSerialize`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs","byte_start":2705,"byte_end":2705,"line_start":93,"line_end":93,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"impl<K: AffineRepr> Witness<ThinVrf<K>> {","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":" + ark_serialize::CanonicalSerialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `K: CanonicalSerialize` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs:102:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        t.append(&r);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CanonicalSerialize` is not implemented for `K`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `Transcript::append`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/ark-transcript/src/lib.rs:317:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m317\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn append<O: CanonicalSerialize+?Sized>(&mut self, itm: &O) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Transcript::append`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `K` with trait `CanonicalSerialize`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m93\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mimpl<K: AffineRepr\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::CanonicalSerialize\u001b[0m\u001b[0m> Witness<ThinVrf<K>> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `K: CanonicalSerialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs","byte_start":5250,"byte_end":5262,"line_start":164,"line_end":164,"column_start":18,"column_end":30,"is_primary":true,"text":[{"text":"        t.append(&signature.r);","highlight_start":18,"highlight_end":30}],"label":"the trait `CanonicalSerialize` is not implemented for `K`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs","byte_start":5243,"byte_end":5249,"line_start":164,"line_end":164,"column_start":11,"column_end":17,"is_primary":false,"text":[{"text":"        t.append(&signature.r);","highlight_start":11,"highlight_end":17}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required by a bound in `Transcript::append`","code":null,"level":"note","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/ark-transcript/src/lib.rs","byte_start":10142,"byte_end":10160,"line_start":317,"line_end":317,"column_start":22,"column_end":40,"is_primary":true,"text":[{"text":"    pub fn append<O: CanonicalSerialize+?Sized>(&mut self, itm: &O) {","highlight_start":22,"highlight_end":40}],"label":"required by this bound in `Transcript::append`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider further restricting type parameter `K` with trait `CanonicalSerialize`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs","byte_start":3981,"byte_end":3981,"line_start":130,"line_end":130,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"impl<K: AffineRepr> ThinVrf<K> {","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":" + ark_serialize::CanonicalSerialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `K: CanonicalSerialize` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/thin.rs:164:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m164\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        t.append(&signature.r);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CanonicalSerialize` is not implemented for `K`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `Transcript::append`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/ark-transcript/src/lib.rs:317:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m317\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn append<O: CanonicalSerialize+?Sized>(&mut self, itm: &O) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Transcript::append`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `K` with trait `CanonicalSerialize`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m130\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mimpl<K: AffineRepr\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::CanonicalSerialize\u001b[0m\u001b[0m> ThinVrf<K> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `<C as AffineRepr>::ScalarField: CanonicalSerialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":1761,"byte_end":1779,"line_start":64,"line_end":64,"column_start":16,"column_end":34,"is_primary":true,"text":[{"text":"#[derive(Clone,CanonicalSerialize,CanonicalDeserialize)] // Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash","highlight_start":16,"highlight_end":34}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":1761,"byte_end":1779,"line_start":64,"line_end":64,"column_start":16,"column_end":34,"is_primary":false,"text":[{"text":"#[derive(Clone,CanonicalSerialize,CanonicalDeserialize)] // Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash","highlight_start":16,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalSerialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":304,"byte_end":396,"line_start":19,"line_end":19,"column_start":1,"column_end":93,"is_primary":false,"text":[{"text":"pub fn derive_canonical_serialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":93}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `CanonicalSerialize` is not implemented for `<C as AffineRepr>::ScalarField`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `[<C as AffineRepr>::ScalarField; B]` to implement `CanonicalSerialize`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `<C as AffineRepr>::ScalarField: CanonicalSerialize` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs:64:16\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m64\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Clone,CanonicalSerialize,CanonicalDeserialize)] // Copy, Default, \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munsatisfied trait bound\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `CanonicalSerialize` is not implemented for `<C as AffineRepr>::ScalarField`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `[<C as AffineRepr>::ScalarField; B]` to implement `CanonicalSerialize`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalSerialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `<C as AffineRepr>::ScalarField: CanonicalDeserialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":1780,"byte_end":1800,"line_start":64,"line_end":64,"column_start":35,"column_end":55,"is_primary":true,"text":[{"text":"#[derive(Clone,CanonicalSerialize,CanonicalDeserialize)] // Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash","highlight_start":35,"highlight_end":55}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":1780,"byte_end":1800,"line_start":64,"line_end":64,"column_start":35,"column_end":55,"is_primary":false,"text":[{"text":"#[derive(Clone,CanonicalSerialize,CanonicalDeserialize)] // Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash","highlight_start":35,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalDeserialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":567,"byte_end":661,"line_start":25,"line_end":25,"column_start":1,"column_end":95,"is_primary":false,"text":[{"text":"pub fn derive_canonical_deserialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `CanonicalDeserialize` is not implemented for `<C as AffineRepr>::ScalarField`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `[<C as AffineRepr>::ScalarField; B]` to implement `Valid`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `ark_serialize::CanonicalDeserialize::deserialize_with_mode`","code":null,"level":"note","spans":[{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-0.4.2/src/lib.rs","byte_start":3440,"byte_end":3461,"line_start":128,"line_end":128,"column_start":8,"column_end":29,"is_primary":false,"text":[{"text":"    fn deserialize_with_mode<R: Read>(","highlight_start":8,"highlight_end":29}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-0.4.2/src/lib.rs","byte_start":3351,"byte_end":3356,"line_start":126,"line_end":126,"column_start":33,"column_end":38,"is_primary":true,"text":[{"text":"pub trait CanonicalDeserialize: Valid {","highlight_start":33,"highlight_end":38}],"label":"required by this bound in `CanonicalDeserialize::deserialize_with_mode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `<C as AffineRepr>::ScalarField: CanonicalDeserialize` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs:64:35\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m64\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mcalSerialize,CanonicalDeserialize)] // Copy, Default, PartialEq, Eq, Pa\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munsatisfied trait bound\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `CanonicalDeserialize` is not implemented for `<C as AffineRepr>::ScalarField`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `[<C as AffineRepr>::ScalarField; B]` to implement `Valid`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `ark_serialize::CanonicalDeserialize::deserialize_with_mode`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-0.4.2/src/lib.rs:126:33\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m126\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait CanonicalDeserialize: Valid {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `CanonicalDeserialize::deserialize_with_mode`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m127\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// The general deserialize method that takes in customization flags.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m128\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn deserialize_with_mode<R: Read>(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this associated function\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `<C as AffineRepr>::ScalarField: CanonicalDeserialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":1780,"byte_end":1800,"line_start":64,"line_end":64,"column_start":35,"column_end":55,"is_primary":true,"text":[{"text":"#[derive(Clone,CanonicalSerialize,CanonicalDeserialize)] // Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash","highlight_start":35,"highlight_end":55}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":1780,"byte_end":1800,"line_start":64,"line_end":64,"column_start":35,"column_end":55,"is_primary":false,"text":[{"text":"#[derive(Clone,CanonicalSerialize,CanonicalDeserialize)] // Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash","highlight_start":35,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalDeserialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":567,"byte_end":661,"line_start":25,"line_end":25,"column_start":1,"column_end":95,"is_primary":false,"text":[{"text":"pub fn derive_canonical_deserialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `CanonicalDeserialize` is not implemented for `<C as AffineRepr>::ScalarField`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `[<C as AffineRepr>::ScalarField; B]` to implement `Valid`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `<C as AffineRepr>::ScalarField: CanonicalDeserialize` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs:64:35\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m64\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0micalSerialize,CanonicalDeserialize)] // Copy, Default, PartialEq, Eq, Pa\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munsatisfied trait bound\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `CanonicalDeserialize` is not implemented for `<C as AffineRepr>::ScalarField`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `[<C as AffineRepr>::ScalarField; B]` to implement `Valid`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `C: CanonicalSerialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":3555,"byte_end":3573,"line_start":120,"line_end":120,"column_start":40,"column_end":58,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,PartialEq,Eq,Hash,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":40,"highlight_end":58}],"label":"the trait `CanonicalSerialize` is not implemented for `C`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":3555,"byte_end":3573,"line_start":120,"line_end":120,"column_start":40,"column_end":58,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,PartialEq,Eq,Hash,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":40,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalSerialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":304,"byte_end":396,"line_start":19,"line_end":19,"column_start":1,"column_end":93,"is_primary":false,"text":[{"text":"pub fn derive_canonical_serialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":93}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider further restricting type parameter `C` with trait `CanonicalSerialize`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":3635,"byte_end":3635,"line_start":121,"line_end":121,"column_start":39,"column_end":39,"is_primary":true,"text":[{"text":"pub struct KeyCommitment<C: AffineRepr>(pub C);","highlight_start":39,"highlight_end":39}],"label":null,"suggested_replacement":" + ark_serialize::CanonicalSerialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `C: CanonicalSerialize` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs:120:40\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m120\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mne,PartialEq,Eq,Hash,CanonicalSerialize,CanonicalDeserialize)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CanonicalSerialize` is not implemented for `C`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalSerialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `C` with trait `CanonicalSerialize`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub struct KeyCommitment<C: AffineRepr\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::CanonicalSerialize\u001b[0m\u001b[0m>(pub C);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `C: CanonicalDeserialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":3574,"byte_end":3594,"line_start":120,"line_end":120,"column_start":59,"column_end":79,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,PartialEq,Eq,Hash,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":59,"highlight_end":79}],"label":"the trait `CanonicalDeserialize` is not implemented for `C`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":3574,"byte_end":3594,"line_start":120,"line_end":120,"column_start":59,"column_end":79,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,PartialEq,Eq,Hash,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":59,"highlight_end":79}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalDeserialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":567,"byte_end":661,"line_start":25,"line_end":25,"column_start":1,"column_end":95,"is_primary":false,"text":[{"text":"pub fn derive_canonical_deserialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider further restricting type parameter `C` with trait `CanonicalDeserialize`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":3635,"byte_end":3635,"line_start":121,"line_end":121,"column_start":39,"column_end":39,"is_primary":true,"text":[{"text":"pub struct KeyCommitment<C: AffineRepr>(pub C);","highlight_start":39,"highlight_end":39}],"label":null,"suggested_replacement":" + ark_serialize::CanonicalDeserialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `C: CanonicalDeserialize` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs:120:59\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m120\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mh,CanonicalSerialize,CanonicalDeserialize)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CanonicalDeserialize` is not implemented for `C`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `C` with trait `CanonicalDeserialize`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub struct KeyCommitment<C: AffineRepr\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::CanonicalDeserialize\u001b[0m\u001b[0m>(pub C);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `C: Valid` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":3574,"byte_end":3594,"line_start":120,"line_end":120,"column_start":59,"column_end":79,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,PartialEq,Eq,Hash,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":59,"highlight_end":79}],"label":"the trait `Valid` is not implemented for `C`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":3574,"byte_end":3594,"line_start":120,"line_end":120,"column_start":59,"column_end":79,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,PartialEq,Eq,Hash,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":59,"highlight_end":79}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalDeserialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":567,"byte_end":661,"line_start":25,"line_end":25,"column_start":1,"column_end":95,"is_primary":false,"text":[{"text":"pub fn derive_canonical_deserialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider further restricting type parameter `C` with trait `Valid`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":3635,"byte_end":3635,"line_start":121,"line_end":121,"column_start":39,"column_end":39,"is_primary":true,"text":[{"text":"pub struct KeyCommitment<C: AffineRepr>(pub C);","highlight_start":39,"highlight_end":39}],"label":null,"suggested_replacement":" + ark_serialize::Valid","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `C: Valid` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs:120:59\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m120\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mze,CanonicalDeserialize)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Valid` is not implemented for `C`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `C` with trait `Valid`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m121\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub struct KeyCommitment<C: AffineRepr\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::Valid\u001b[0m\u001b[0m>(pub C);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                        \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `SF: CanonicalSerialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4302,"byte_end":4320,"line_start":149,"line_end":149,"column_start":22,"column_end":40,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":22,"highlight_end":40}],"label":"the trait `CanonicalSerialize` is not implemented for `SF`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4302,"byte_end":4320,"line_start":149,"line_end":149,"column_start":22,"column_end":40,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":22,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalSerialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":304,"byte_end":396,"line_start":19,"line_end":19,"column_start":1,"column_end":93,"is_primary":false,"text":[{"text":"pub fn derive_canonical_serialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":93}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider further restricting type parameter `SF` with trait `CanonicalSerialize`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4377,"byte_end":4377,"line_start":150,"line_end":150,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"pub struct Scalars<SF: PrimeField,const B: usize> {","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":" + ark_serialize::CanonicalSerialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `SF: CanonicalSerialize` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs:149:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m149\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CanonicalSerialize` is not implemented for `SF`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalSerialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `SF` with trait `CanonicalSerialize`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m150\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub struct Scalars<SF: PrimeField\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::CanonicalSerialize\u001b[0m\u001b[0m,const B: usize> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `SF: CanonicalDeserialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4321,"byte_end":4341,"line_start":149,"line_end":149,"column_start":41,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":41,"highlight_end":61}],"label":"the trait `CanonicalDeserialize` is not implemented for `SF`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4321,"byte_end":4341,"line_start":149,"line_end":149,"column_start":41,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":41,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalDeserialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":567,"byte_end":661,"line_start":25,"line_end":25,"column_start":1,"column_end":95,"is_primary":false,"text":[{"text":"pub fn derive_canonical_deserialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider further restricting type parameter `SF` with trait `CanonicalDeserialize`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4377,"byte_end":4377,"line_start":150,"line_end":150,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"pub struct Scalars<SF: PrimeField,const B: usize> {","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":" + ark_serialize::CanonicalDeserialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `SF: CanonicalDeserialize` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs:149:41\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m149\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CanonicalDeserialize` is not implemented for `SF`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `SF` with trait `CanonicalDeserialize`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m150\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub struct Scalars<SF: PrimeField\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::CanonicalDeserialize\u001b[0m\u001b[0m,const B: usize> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `SF: Valid` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4321,"byte_end":4341,"line_start":149,"line_end":149,"column_start":41,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":41,"highlight_end":61}],"label":"the trait `Valid` is not implemented for `SF`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4321,"byte_end":4341,"line_start":149,"line_end":149,"column_start":41,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":41,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalDeserialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":567,"byte_end":661,"line_start":25,"line_end":25,"column_start":1,"column_end":95,"is_primary":false,"text":[{"text":"pub fn derive_canonical_deserialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider further restricting type parameter `SF` with trait `Valid`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4377,"byte_end":4377,"line_start":150,"line_end":150,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"pub struct Scalars<SF: PrimeField,const B: usize> {","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":" + ark_serialize::Valid","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `SF: Valid` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs:149:41\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m149\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Valid` is not implemented for `SF`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `SF` with trait `Valid`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m150\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub struct Scalars<SF: PrimeField\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::Valid\u001b[0m\u001b[0m,const B: usize> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `SF: CanonicalDeserialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4321,"byte_end":4341,"line_start":149,"line_end":149,"column_start":41,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":41,"highlight_end":61}],"label":"the trait `CanonicalDeserialize` is not implemented for `SF`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4321,"byte_end":4341,"line_start":149,"line_end":149,"column_start":41,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":41,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalDeserialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":567,"byte_end":661,"line_start":25,"line_end":25,"column_start":1,"column_end":95,"is_primary":false,"text":[{"text":"pub fn derive_canonical_deserialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"required for `[SF; B]` to implement `Valid`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider further restricting type parameter `SF` with trait `CanonicalDeserialize`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4377,"byte_end":4377,"line_start":150,"line_end":150,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"pub struct Scalars<SF: PrimeField,const B: usize> {","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":" + ark_serialize::CanonicalDeserialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `SF: CanonicalDeserialize` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs:149:41\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m149\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CanonicalDeserialize` is not implemented for `SF`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required for `[SF; B]` to implement `Valid`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `SF` with trait `CanonicalDeserialize`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m150\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub struct Scalars<SF: PrimeField\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::CanonicalDeserialize\u001b[0m\u001b[0m,const B: usize> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `K: CanonicalSerialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4690,"byte_end":4708,"line_start":164,"line_end":164,"column_start":22,"column_end":40,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":22,"highlight_end":40}],"label":"the trait `CanonicalSerialize` is not implemented for `K`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4690,"byte_end":4708,"line_start":164,"line_end":164,"column_start":22,"column_end":40,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":22,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalSerialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":304,"byte_end":396,"line_start":19,"line_end":19,"column_start":1,"column_end":93,"is_primary":false,"text":[{"text":"pub fn derive_canonical_serialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":93}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider further restricting type parameter `K` with trait `CanonicalSerialize`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4776,"byte_end":4776,"line_start":166,"line_end":166,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"where K: AffineRepr, H: AffineRepr<ScalarField = K::ScalarField>,","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":" + ark_serialize::CanonicalSerialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `K: CanonicalSerialize` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs:164:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m164\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CanonicalSerialize` is not implemented for `K`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalSerialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `K` with trait `CanonicalSerialize`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m166\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mwhere K: AffineRepr\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::CanonicalSerialize\u001b[0m\u001b[0m, H: AffineRepr<ScalarField = K::ScalarField>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `H: CanonicalSerialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4690,"byte_end":4708,"line_start":164,"line_end":164,"column_start":22,"column_end":40,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":22,"highlight_end":40}],"label":"the trait `CanonicalSerialize` is not implemented for `H`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4690,"byte_end":4708,"line_start":164,"line_end":164,"column_start":22,"column_end":40,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":22,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalSerialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":304,"byte_end":396,"line_start":19,"line_end":19,"column_start":1,"column_end":93,"is_primary":false,"text":[{"text":"pub fn derive_canonical_serialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":93}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider further restricting type parameter `H` with trait `CanonicalSerialize`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4821,"byte_end":4821,"line_start":166,"line_end":166,"column_start":65,"column_end":65,"is_primary":true,"text":[{"text":"where K: AffineRepr, H: AffineRepr<ScalarField = K::ScalarField>,","highlight_start":65,"highlight_end":65}],"label":null,"suggested_replacement":" + ark_serialize::CanonicalSerialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `H: CanonicalSerialize` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs:164:22\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m164\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CanonicalSerialize` is not implemented for `H`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalSerialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `H` with trait `CanonicalSerialize`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m166\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mwhere K: AffineRepr, H: AffineRepr<ScalarField = K::ScalarField>\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::CanonicalSerialize\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                  \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `K: CanonicalDeserialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4709,"byte_end":4729,"line_start":164,"line_end":164,"column_start":41,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":41,"highlight_end":61}],"label":"the trait `CanonicalDeserialize` is not implemented for `K`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4709,"byte_end":4729,"line_start":164,"line_end":164,"column_start":41,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":41,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalDeserialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":567,"byte_end":661,"line_start":25,"line_end":25,"column_start":1,"column_end":95,"is_primary":false,"text":[{"text":"pub fn derive_canonical_deserialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider further restricting type parameter `K` with trait `CanonicalDeserialize`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4776,"byte_end":4776,"line_start":166,"line_end":166,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"where K: AffineRepr, H: AffineRepr<ScalarField = K::ScalarField>,","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":" + ark_serialize::CanonicalDeserialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `K: CanonicalDeserialize` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs:164:41\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m164\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CanonicalDeserialize` is not implemented for `K`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `K` with trait `CanonicalDeserialize`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m166\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mwhere K: AffineRepr\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::CanonicalDeserialize\u001b[0m\u001b[0m, H: AffineRepr<ScalarField = K::ScalarField>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `H: CanonicalDeserialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4709,"byte_end":4729,"line_start":164,"line_end":164,"column_start":41,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":41,"highlight_end":61}],"label":"the trait `CanonicalDeserialize` is not implemented for `H`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4709,"byte_end":4729,"line_start":164,"line_end":164,"column_start":41,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":41,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalDeserialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":567,"byte_end":661,"line_start":25,"line_end":25,"column_start":1,"column_end":95,"is_primary":false,"text":[{"text":"pub fn derive_canonical_deserialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider further restricting type parameter `H` with trait `CanonicalDeserialize`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4821,"byte_end":4821,"line_start":166,"line_end":166,"column_start":65,"column_end":65,"is_primary":true,"text":[{"text":"where K: AffineRepr, H: AffineRepr<ScalarField = K::ScalarField>,","highlight_start":65,"highlight_end":65}],"label":null,"suggested_replacement":" + ark_serialize::CanonicalDeserialize","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `H: CanonicalDeserialize` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs:164:41\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m164\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CanonicalDeserialize` is not implemented for `H`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `H` with trait `CanonicalDeserialize`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m166\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mwhere K: AffineRepr, H: AffineRepr<ScalarField = K::ScalarField>\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::CanonicalDeserialize\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                  \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `K: Valid` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4709,"byte_end":4729,"line_start":164,"line_end":164,"column_start":41,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":41,"highlight_end":61}],"label":"the trait `Valid` is not implemented for `K`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4709,"byte_end":4729,"line_start":164,"line_end":164,"column_start":41,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":41,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalDeserialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":567,"byte_end":661,"line_start":25,"line_end":25,"column_start":1,"column_end":95,"is_primary":false,"text":[{"text":"pub fn derive_canonical_deserialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider further restricting type parameter `K` with trait `Valid`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4776,"byte_end":4776,"line_start":166,"line_end":166,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"where K: AffineRepr, H: AffineRepr<ScalarField = K::ScalarField>,","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":" + ark_serialize::Valid","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `K: Valid` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs:164:41\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m164\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Valid` is not implemented for `K`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `K` with trait `Valid`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m166\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mwhere K: AffineRepr\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::Valid\u001b[0m\u001b[0m, H: AffineRepr<ScalarField = K::ScalarField>,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `H: Valid` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4709,"byte_end":4729,"line_start":164,"line_end":164,"column_start":41,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":41,"highlight_end":61}],"label":"the trait `Valid` is not implemented for `H`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4709,"byte_end":4729,"line_start":164,"line_end":164,"column_start":41,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]","highlight_start":41,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(CanonicalDeserialize)]","def_site_span":{"file_name":"/home/danie/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ark-serialize-derive-0.4.2/src/lib.rs","byte_start":567,"byte_end":661,"line_start":25,"line_end":25,"column_start":1,"column_end":95,"is_primary":false,"text":[{"text":"pub fn derive_canonical_deserialize(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":95}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider further restricting type parameter `H` with trait `Valid`","code":null,"level":"help","spans":[{"file_name":"/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs","byte_start":4821,"byte_end":4821,"line_start":166,"line_end":166,"column_start":65,"column_end":65,"is_primary":true,"text":[{"text":"where K: AffineRepr, H: AffineRepr<ScalarField = K::ScalarField>,","highlight_start":65,"highlight_end":65}],"label":null,"suggested_replacement":" + ark_serialize::Valid","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the trait bound `H: Valid` is not satisfied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/danie/.cargo/git/checkouts/ring-vrf-c71688ebb05e13dc/c86ebd4/dleq_vrf/src/pedersen.rs:164:41\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m164\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug,Clone,CanonicalSerialize,CanonicalDeserialize)]\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Valid` is not implemented for `H`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the derive macro `CanonicalDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider further restricting type parameter `H` with trait `Valid`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m166\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mwhere K: AffineRepr, H: AffineRepr<ScalarField = K::ScalarField>\u001b[0m\u001b[0m\u001b[38;5;10m + ark_serialize::Valid\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                  \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 32 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 32 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0277`.\u001b[0m\n"}
